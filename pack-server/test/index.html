<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voice Engine</title>
    <link href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@300;400;500;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #e3e6ea;
            --container-bg: #e3e6ea;
            --shadow-dark: #cfd1d4;
            --shadow-light: #ffffff;
            --input-bg: #f0f0f3;
            --text-color: #333;
            --text-muted: #666;
            --panel-bg: #f0f0f3;
            --panel-alt-bg: #ecf3ff;
            --border-color: #dde1e7;
        }
        
        body.dark-mode {
            --bg-color: #35383f;
            --container-bg: #35383f;
            --shadow-dark: #1e2026;
            --shadow-light: #494c54;
            --input-bg: #3c3f47;
            --text-color: #e0e0e0;
            --text-muted: #b0b0b0;
            --panel-bg: #3c3f47;
            --panel-alt-bg: #2a3142;
            --border-color: #494c54;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Ubuntu', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
        }
        
        body {
            background: var(--bg-color);
            color: var(--text-color);
            padding: 20px;
        }
        
        .pattern-dotted {
            background-image: radial-gradient(circle at 1px 1px, var(--shadow-dark) 1.5px, transparent 0);
            background-size: 12px 12px;
            background-color: var(--bg-color);
        }
        
        .dark-mode-toggle {
            margin-left: auto;
            display: flex;
            gap: 10px;
        }
        
        .dark-mode-toggle button {
            background: var(--container-bg);
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            box-shadow: 2px 2px 5px var(--shadow-dark), -2px -2px 5px var(--shadow-light);
            cursor: pointer;
            color: var(--text-color);
            font-weight: bold;
            transition: all 0.1s ease;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .dark-mode-toggle button:active {
            box-shadow: inset 2px 2px 5px var(--shadow-dark), inset -2px -2px 5px var(--shadow-light);
        }
        
        .rotate-360 {
            animation: rotate360 0.6s ease-in-out;
        }
        
        @keyframes rotate360 {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        
        .main-container {
            display: flex;
            gap: 20px;
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .left-panel {
            flex: 0 0 320px;
        }
        
        .video-container {
            background: var(--container-bg);
            border-radius: 5px;
            padding: 15px;
            box-shadow: 5px 5px 15px var(--shadow-dark), -5px -5px 15px var(--shadow-light);
            margin-bottom: 20px;
        }
        
        .video-wrapper {
            background: var(--input-bg);
            border-radius: 5px;
            padding: 4px;
            box-shadow: inset 3px 3px 6px var(--shadow-dark), inset -3px -3px 6px var(--shadow-light);
            position: relative;
            transition: box-shadow 0.1s ease;
        }
        
        .audio-visualizer {
            position: absolute;
            bottom: 8px;
            left: 50%;
            transform: translateX(-50%);
            width: 60px;
            height: 20px;
            background: var(--container-bg);
            border-radius: 10px;
            box-shadow: inset 2px 2px 4px var(--shadow-dark), inset -2px -2px 4px var(--shadow-light);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 2px;
            padding: 4px;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .audio-visualizer.active {
            opacity: 1;
        }
        
        .audio-bar {
            width: 3px;
            background: var(--text-color);
            border-radius: 2px;
            transition: height 0.1s ease;
            min-height: 2px;
        }
        
        video {
            width: 100%;
            height: 240px;
            border-radius: 3px;
            object-fit: cover;
            display: block;
        }
        
        .controls {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }
        
        .btn {
            flex: 1;
            padding: 10px;
            border: none;
            border-radius: 5px;
            background: var(--container-bg);
            box-shadow: 3px 3px 6px var(--shadow-dark), -3px -3px 6px var(--shadow-light);
            cursor: pointer;
            font-weight: bold;
            color: var(--text-color);
            transition: all 0.1s ease;
            font-size: 14px;
        }
        
        .btn:active {
            box-shadow: inset 3px 3px 6px var(--shadow-dark), inset -3px -3px 6px var(--shadow-light);
            transform: scale(0.98);
        }
        
        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            box-shadow: inset 2px 2px 4px var(--shadow-dark), inset -2px -2px 4px var(--shadow-light);
        }
        
        .btn-circular {
            background: var(--container-bg);
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            box-shadow: 3px 3px 6px var(--shadow-dark), -3px -3px 6px var(--shadow-light);
            cursor: pointer;
            color: var(--text-color);
            transition: all 0.1s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .btn-circular.pressed {
            box-shadow: inset 3px 3px 6px var(--shadow-dark), inset -3px -3px 6px var(--shadow-light);
        }
        
        .btn-circular.pressed svg {
            width: 14px;
            height: 14px;
        }
        
        
        .panel {
            background: var(--container-bg);
            border-radius: 5px;
            padding: 15px;
            margin-bottom: 15px;
            box-shadow: 5px 5px 15px var(--shadow-dark), -5px -5px 15px var(--shadow-light);
            font-size: 12px;
            font-family: monospace;
        }
        
        .panel-title {
            font-weight: bold;
            margin-bottom: 10px;
            color: var(--text-color);
            font-size: 14px;
        }
        
        .panel-row {
            margin-bottom: 5px;
            display: flex;
            justify-content: space-between;
        }
        
        .status-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 5px;
        }
        
        
        .right-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        
        .header {
            background: var(--container-bg);
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
            box-shadow: 5px 5px 15px var(--shadow-dark), -5px -5px 15px var(--shadow-light);
            display: flex;
            align-items: center;
            max-width: 1200px;
            margin: 0 auto 20px auto;
        }
        
        .header h3 {
            margin: 0;
            color: var(--text-color);
            font-family: 'VT323', monospace;
            font-size: 32px;
            font-weight: 400;
            letter-spacing: 0.05em;
        }
        
        .chat-container {
            overflow-y: auto;
            background: var(--container-bg);
            border-radius: 5px;
            padding: 20px;
            box-shadow: 5px 5px 15px var(--shadow-dark), -5px -5px 15px var(--shadow-light);
            height: calc(100vh - 140px);
            min-height: 500px;
        }
        
        .chat-message {
            background: var(--input-bg);
            padding: 12px 15px;
            margin-bottom: 12px;
            border-radius: 5px;
            white-space: pre-wrap;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.4;
            box-shadow: inset 3px 3px 8px var(--shadow-dark), inset -3px -3px 8px var(--shadow-light);
            color: var(--text-color);
        }
        
        .chat-message.user {
            background: var(--panel-alt-bg);
            margin-left: 20%;
            text-align: right;
            box-shadow: inset 2px 2px 5px var(--shadow-dark), inset -2px -2px 5px var(--shadow-light);
        }
        
        .chat-message.interrupted {
            color: var(--text-muted);
            opacity: 0.7;
        }
        
        .interrupt-icon {
            font-size: 12px;
            opacity: 0.7;
            margin-left: 8px;
        }
        
        /* Scrollbar styling */
        .chat-container::-webkit-scrollbar {
            width: 8px;
        }
        
        .chat-container::-webkit-scrollbar-track {
            background: var(--input-bg);
            border-radius: 5px;
        }
        
        .chat-container::-webkit-scrollbar-thumb {
            background: var(--shadow-dark);
            border-radius: 5px;
        }
        
        .chat-container::-webkit-scrollbar-thumb:hover {
            background: var(--text-muted);
        }
        
        /* AI Avatar Styles */
        .ai-avatar-container {
            background: var(--container-bg);
            border-radius: 5px;
            padding: 15px;
            box-shadow: 5px 5px 15px var(--shadow-dark), -5px -5px 15px var(--shadow-light);
            margin-bottom: 20px;
        }
        
        .ai-avatar-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }
        
        .ai-avatar {
            position: relative;
            width: 120px;
            height: 120px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .avatar-core {
            position: absolute;
            width: 80px;
            height: 80px;
            background: var(--container-bg);
            border-radius: 50%;
            box-shadow: inset 5px 5px 10px var(--shadow-dark), inset -5px -5px 10px var(--shadow-light);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
            transition: all 0.3s ease;
        }
        
        .avatar-icon {
            color: var(--text-color);
            opacity: 0.8;
            transition: all 0.3s ease;
        }
        
        .avatar-wave {
            position: absolute;
            border: 2px solid;
            border-radius: 50%;
            opacity: 0;
            transform: scale(0.8);
            transition: all 0.4s ease;
        }
        
        .wave-1 {
            width: 90px;
            height: 90px;
            border-color: #007bff;
            animation-delay: 0s;
        }
        
        .wave-2 {
            width: 100px;
            height: 100px;
            border-color: #007bff;
            animation-delay: 0.2s;
        }
        
        .wave-3 {
            width: 110px;
            height: 110px;
            border-color: #007bff;
            animation-delay: 0.4s;
        }
        
        /* AI Speaking Animation */
        .ai-avatar.speaking .avatar-core {
            box-shadow: inset 3px 3px 8px var(--shadow-dark), inset -3px -3px 8px var(--shadow-light),
                        0 0 20px rgba(0, 123, 255, 0.3);
        }
        
        .ai-avatar.speaking .avatar-icon {
            color: #007bff;
            opacity: 1;
        }
        
        .ai-avatar.speaking .avatar-wave {
            opacity: 0.6;
            transform: scale(1.2);
            animation: avatar-pulse 2s infinite ease-in-out;
        }
        
        /* Gemini Provider Colors */
        .ai-avatar.gemini .wave-1,
        .ai-avatar.gemini .wave-2,
        .ai-avatar.gemini .wave-3 {
            border-color: #4285f4;
        }
        
        .ai-avatar.gemini.speaking .avatar-core {
            box-shadow: inset 3px 3px 8px var(--shadow-dark), inset -3px -3px 8px var(--shadow-light),
                        0 0 20px rgba(66, 133, 244, 0.3);
        }
        
        .ai-avatar.gemini.speaking .avatar-icon {
            color: #4285f4;
        }
        
        .avatar-label {
            font-size: 14px;
            font-weight: 500;
            color: var(--text-color);
            text-align: center;
        }
        
        @keyframes avatar-pulse {
            0% {
                transform: scale(0.8);
                opacity: 0.8;
            }
            50% {
                transform: scale(1.2);
                opacity: 0.3;
            }
            100% {
                transform: scale(1.4);
                opacity: 0;
            }
        }
        
        /* Breathing Orb Styles */
        /* Combined AI Service Panel Styles */
        .ai-service-container {
            background: var(--container-bg);
            border-radius: 5px;
            padding: 15px;
            box-shadow: 5px 5px 15px var(--shadow-dark), -5px -5px 15px var(--shadow-light);
            margin-bottom: 20px;
        }
        
        .ai-service-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
        }
        
        .breathing-orb {
            position: relative;
            width: 100px;
            height: 100px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .service-info-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            font-size: 14px;
            font-weight: 500;
        }
        
        .service-name {
            display: flex;
            align-items: center;
            gap: 6px;
            color: var(--text-color);
        }
        
        
        .orb-container {
            background: var(--input-bg);
            border-radius: 5px;
            padding: 15px;
            box-shadow: inset 3px 3px 6px var(--shadow-dark), inset -3px -3px 6px var(--shadow-light);
            position: relative;
            transition: box-shadow 0.1s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            margin-bottom: 12px;
            height: 165px;
        }
        
        .orb-outer-wrapper {
            background: transparent;
            padding: 12px;
            border-radius: 50%;
            box-shadow: none;
            transition: all 0.6s ease;
        }
        
        .orb-middle-wrapper {
            background: transparent;
            padding: 12px;
            border-radius: 50%;
            box-shadow: none;
            transition: all 0.6s ease;
        }
        
        .orb-core {
            position: relative;
            width: 48px;
            height: 48px;
            background: transparent;
            border-radius: 50%;
            box-shadow: none;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
            transition: all 0.6s ease;
        }
        
        
        .orb-controls {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
        }
        
        .orb-label {
            font-size: 14px;
            font-weight: 500;
            color: var(--text-color);
            text-align: center;
            flex: 1;
        }
        
        
        .btn-test {
            background: var(--container-bg);
            border: none;
            border-radius: 8px;
            padding: 6px 12px;
            font-size: 12px;
            font-weight: 500;
            color: var(--text-color);
            box-shadow: 2px 2px 4px var(--shadow-dark), -2px -2px 4px var(--shadow-light);
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: inherit;
        }
        
        .btn-test:hover {
            box-shadow: 3px 3px 6px var(--shadow-dark), -3px -3px 6px var(--shadow-light);
        }
        
        .btn-test:active {
            box-shadow: inset 2px 2px 4px var(--shadow-dark), inset -2px -2px 4px var(--shadow-light);
            transform: scale(0.98);
        }
        
        .btn-test.active {
            background: #007bff;
            color: white;
            box-shadow: inset 2px 2px 4px var(--shadow-dark), inset -2px -2px 4px var(--shadow-light);
        }
        
        body.dark-mode .btn-test.active {
            background: #007bff;
            color: white;
        }
        
        /* Test Mode - Clean Slate */
        .breathing-orb.test-mode .orb-inner-glow {
            opacity: 0 !important;
            animation: none !important;
        }
        
        .breathing-orb.test-mode .orb-outer-glow {
            opacity: 0 !important;
            animation: none !important;
        }
        
        .breathing-orb.test-mode .orb-pulse {
            opacity: 0 !important;
            animation: none !important;
        }
        
        .breathing-orb.test-mode .orb-outer-wrapper {
            animation: none !important;
        }
        
        .breathing-orb.test-mode .orb-core {
            animation: none !important;
        }


        /* Style 5: Neural Fire Animation */
        .breathing-orb.neural-fire .orb-core {
            animation: neural-inner 2.5s infinite ease-in-out;
        }
        
        .breathing-orb.neural-fire .orb-middle-wrapper {
            animation: neural-middle 2.5s infinite ease-in-out;
        }
        
        .breathing-orb.neural-fire .orb-outer-wrapper {
            animation: neural-outer 2.5s infinite ease-in-out;
        }

        @keyframes neural-inner {
            0%, 100% { 
                box-shadow: none; 
                background: transparent;
            }
            10% { 
                box-shadow: inset 3px 3px 6px var(--shadow-dark), inset -3px -3px 6px var(--shadow-light); 
                background: var(--container-bg);
            }
            20% { 
                box-shadow: -6px -6px 12px var(--shadow-light), 6px 6px 12px var(--shadow-dark); 
                background: var(--container-bg);
            }
            30%, 40% { 
                box-shadow: none; 
                background: transparent;
            }
            70% { 
                box-shadow: none; 
                background: transparent;
            }
            80% { 
                box-shadow: -6px -6px 12px var(--shadow-light), 6px 6px 12px var(--shadow-dark); 
                background: var(--container-bg);
            }
            90% { 
                box-shadow: inset 3px 3px 6px var(--shadow-dark), inset -3px -3px 6px var(--shadow-light); 
                background: var(--container-bg);
            }
        }

        @keyframes neural-middle {
            0%, 19% { 
                box-shadow: none; 
                background: transparent;
            }
            20% { 
                box-shadow: -6px -6px 12px var(--shadow-light), 6px 6px 12px var(--shadow-dark); 
                background: var(--container-bg);
            }
            30% { 
                box-shadow: inset 4px 4px 8px var(--shadow-dark), inset -4px -4px 8px var(--shadow-light); 
                background: var(--container-bg);
            }
            40%, 60% { 
                box-shadow: none; 
                background: transparent;
            }
            70% { 
                box-shadow: inset 4px 4px 8px var(--shadow-dark), inset -4px -4px 8px var(--shadow-light); 
                background: var(--container-bg);
            }
            80% { 
                box-shadow: -6px -6px 12px var(--shadow-light), 6px 6px 12px var(--shadow-dark); 
                background: var(--container-bg);
            }
            90%, 100% { 
                box-shadow: none; 
                background: transparent;
            }
        }

        @keyframes neural-outer {
            0%, 29% { 
                box-shadow: none; 
                background: transparent;
            }
            30% { 
                box-shadow: -8px -8px 16px var(--shadow-light), 8px 8px 16px var(--shadow-dark); 
                background: var(--container-bg);
            }
            40% { 
                box-shadow: inset -6px -6px 12px var(--shadow-light), inset 6px 6px 12px var(--shadow-dark); 
                background: var(--container-bg);
            }
            50%, 60% { 
                box-shadow: -8px -8px 16px var(--shadow-light), 8px 8px 16px var(--shadow-dark); 
                background: var(--container-bg);
            }
            70% { 
                box-shadow: inset -6px -6px 12px var(--shadow-light), inset 6px 6px 12px var(--shadow-dark); 
                background: var(--container-bg);
            }
            80% { 
                box-shadow: -8px -8px 16px var(--shadow-light), 8px 8px 16px var(--shadow-dark); 
                background: var(--container-bg);
            }
            90%, 100% { 
                box-shadow: none; 
                background: transparent;
            }
        }
        
        @keyframes orb-breathe {
            0%, 100% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.1);
            }
        }
        
        @keyframes glow-breathe {
            0%, 100% {
                transform: scale(1);
                opacity: 0.4;
            }
            50% {
                transform: scale(1.2);
                opacity: 0.6;
            }
        }
        
        @keyframes outer-glow-breathe {
            0%, 100% {
                transform: scale(1);
                opacity: 0.6;
            }
            50% {
                transform: scale(1.3);
                opacity: 0.3;
            }
        }
        
        @keyframes orb-wrapper-speaking {
            0%, 100% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.05);
            }
        }
        
        @keyframes orb-speaking {
            0%, 100% {
                transform: scale(1);
            }
            25% {
                transform: scale(1.05);
            }
            75% {
                transform: scale(1.15);
            }
        }
        
        @keyframes glow-speaking {
            0%, 100% {
                transform: scale(1);
                opacity: 0.8;
            }
            50% {
                transform: scale(1.4);
                opacity: 1;
            }
        }
        
        @keyframes outer-glow-speaking {
            0%, 100% {
                transform: scale(1);
                opacity: 0.8;
            }
            50% {
                transform: scale(1.6);
                opacity: 0.4;
            }
        }
        
        @keyframes pulse-speaking {
            0% {
                transform: scale(0.5);
                opacity: 0.8;
            }
            100% {
                transform: scale(1.5);
                opacity: 0;
            }
        }
        
        
    </style>
</head>
<body class="pattern-dotted">
    <div class="header">
        <h3>{ realtimeSwitch }</h3>
        <div class="header-controls" style="margin-left: auto; display: flex; gap: 20px; align-items: center;">
            <!-- API Style Toggler -->
            <div style="display: flex; align-items: center; gap: 8px;">
                <span style="font-size: 12px; color: var(--text-muted); font-weight: 500;">API Style:</span>
                <button id="apiStyleToggle" onclick="toggleApiStyle()" style="background: var(--container-bg); border: none; border-radius: 20px; padding: 6px 12px; box-shadow: 2px 2px 5px var(--shadow-dark), -2px -2px 5px var(--shadow-light); cursor: pointer; color: var(--text-color); font-size: 12px; font-weight: 500; display: flex; align-items: center; gap: 6px; transition: all 0.2s ease;">
                    <svg id="apiStyleIcon" width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M22.2819 9.8211a5.9847 5.9847 0 0 0-.5157-4.9108 6.0462 6.0462 0 0 0-6.5098-2.9A6.0651 6.0651 0 0 0 4.9807 4.1818a5.9847 5.9847 0 0 0-3.9977 2.9 6.0462 6.0462 0 0 0 .7427 7.0966 5.98 5.98 0 0 0 .511 4.9107 6.051 6.051 0 0 0 6.5146 2.9001A5.9847 5.9847 0 0 0 13.2599 24a6.0557 6.0557 0 0 0 5.7718-4.2058 5.9894 5.9894 0 0 0 3.9977-2.9001 6.0557 6.0557 0 0 0-.7475-7.0729zm-9.022 12.6081a4.4755 4.4755 0 0 1-2.8764-1.0408l.1419-.0804 4.7783-2.7582a.7948.7948 0 0 0 .3927-.6813v-6.7369l2.02 1.1686a.071.071 0 0 1 .038.052v5.5826a4.504 4.504 0 0 1-4.4945 4.4944zm-9.6607-4.1254a4.4708 4.4708 0 0 1-.5346-3.0137l.142.0852 4.783 2.7582a.7712.7712 0 0 0 .7806 0l5.8428-3.3685v2.3324a.0804.0804 0 0 1-.0332.0615L9.74 19.9502a4.4992 4.4992 0 0 1-6.1408-1.6464zM2.3408 7.8956a4.485 4.485 0 0 1 2.3655-1.9728V11.6a.7664.7664 0 0 0 .3879.6765l5.8144 3.3543-2.0201 1.1685a.0757.0757 0 0 1-.071 0l-4.8303-2.7865A4.504 4.504 0 0 1 2.3408 7.872zm16.5963 3.8558L13.1038 8.364 15.1192 7.2a.0757.0757 0 0 1 .071 0l4.8303 2.7913a4.4944 4.4944 0 0 1-.6765 8.1042v-5.6772a.79.79 0 0 0-.407-.667zm2.0107-3.0231l-.142-.0852-4.7735-2.7818a.7759.7759 0 0 0-.7854 0L9.409 9.2297V6.8974a.0662.0662 0 0 1 .0284-.0615l4.8303-2.7866a4.4992 4.4992 0 0 1 6.6802 4.66zM8.3065 12.863l-2.02-1.1638a.0804.0804 0 0 1-.038-.0567V6.0742a4.4992 4.4992 0 0 1 7.3757-3.4537l-.142.0805L8.704 5.459a.7948.7948 0 0 0-.3927.6813zm1.0976-2.3654l2.602-1.4998 2.6069 1.4998v2.9994l-2.5974 1.4997-2.6067-1.4997Z"/>
                    </svg>
                    <span id="apiStyleText">OpenAI</span>
                </button>
            </div>
            
            <!-- Provider Toggler -->
            <div style="display: flex; align-items: center; gap: 8px;">
                <span style="font-size: 12px; color: var(--text-muted); font-weight: 500;">Provider:</span>
                <button id="providerToggle" onclick="toggleProvider()" style="background: var(--container-bg); border: none; border-radius: 20px; padding: 6px 12px; box-shadow: 2px 2px 5px var(--shadow-dark), -2px -2px 5px var(--shadow-light); cursor: pointer; color: var(--text-color); font-size: 12px; font-weight: 500; display: flex; align-items: center; gap: 6px; transition: all 0.2s ease;">
                    <svg id="providerIcon" width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M22.2819 9.8211a5.9847 5.9847 0 0 0-.5157-4.9108 6.0462 6.0462 0 0 0-6.5098-2.9A6.0651 6.0651 0 0 0 4.9807 4.1818a5.9847 5.9847 0 0 0-3.9977 2.9 6.0462 6.0462 0 0 0 .7427 7.0966 5.98 5.98 0 0 0 .511 4.9107 6.051 6.051 0 0 0 6.5146 2.9001A5.9847 5.9847 0 0 0 13.2599 24a6.0557 6.0557 0 0 0 5.7718-4.2058 5.9894 5.9894 0 0 0 3.9977-2.9001 6.0557 6.0557 0 0 0-.7475-7.0729zm-9.022 12.6081a4.4755 4.4755 0 0 1-2.8764-1.0408l.1419-.0804 4.7783-2.7582a.7948.7948 0 0 0 .3927-.6813v-6.7369l2.02 1.1686a.071.071 0 0 1 .038.052v5.5826a4.504 4.504 0 0 1-4.4945 4.4944zm-9.6607-4.1254a4.4708 4.4708 0 0 1-.5346-3.0137l.142.0852 4.783 2.7582a.7712.7712 0 0 0 .7806 0l5.8428-3.3685v2.3324a.0804.0804 0 0 1-.0332.0615L9.74 19.9502a4.4992 4.4992 0 0 1-6.1408-1.6464zM2.3408 7.8956a4.485 4.485 0 0 1 2.3655-1.9728V11.6a.7664.7664 0 0 0 .3879.6765l5.8144 3.3543-2.0201 1.1685a.0757.0757 0 0 1-.071 0l-4.8303-2.7865A4.504 4.504 0 0 1 2.3408 7.872zm16.5963 3.8558L13.1038 8.364 15.1192 7.2a.0757.0757 0 0 1 .071 0l4.8303 2.7913a4.4944 4.4944 0 0 1-.6765 8.1042v-5.6772a.79.79 0 0 0-.407-.667zm2.0107-3.0231l-.142-.0852-4.7735-2.7818a.7759.7759 0 0 0-.7854 0L9.409 9.2297V6.8974a.0662.0662 0 0 1 .0284-.0615l4.8303-2.7866a4.4992 4.4992 0 0 1 6.6802 4.66zM8.3065 12.863l-2.02-1.1638a.0804.0804 0 0 1-.038-.0567V6.0742a4.4992 4.4992 0 0 1 7.3757-3.4537l-.142.0805L8.704 5.459a.7948.7948 0 0 0-.3927.6813zm1.0976-2.3654l2.602-1.4998 2.6069 1.4998v2.9994l-2.5974 1.4997-2.6067-1.4997Z"/>
                    </svg>
                    <span id="providerText">OpenAI</span>
                </button>
            </div>
            
            <div class="dark-mode-toggle">
                <button id="darkModeToggle" onclick="toggleDarkMode()">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9"/>
                        <path d="M20 3v4"/>
                        <path d="M22 5h-4"/>
                    </svg>
                </button>
            </div>
        </div>
    </div>
    
    <div class="main-container">
        <div class="left-panel">
            <div class="video-container">
                <div class="video-wrapper">
                    <video id="video" width="320" height="240" muted></video>
                    <div class="audio-visualizer" id="audioVisualizer">
                        <div class="audio-bar"></div>
                        <div class="audio-bar"></div>
                        <div class="audio-bar"></div>
                        <div class="audio-bar"></div>
                        <div class="audio-bar"></div>
                        <div class="audio-bar"></div>
                        <div class="audio-bar"></div>
                        <div class="audio-bar"></div>
                    </div>
                </div>
                <div class="controls">
                    <button id="startBtn" class="btn">Start</button>
                    <button id="stopBtn" class="btn" disabled>Stop</button>
                    <button id="muteBtn" class="btn-circular">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-mic-off-icon lucide-mic-off">
                            <line x1="2" x2="22" y1="2" y2="22"/>
                            <path d="M18.89 13.23A7.12 7.12 0 0 0 19 12v-2"/>
                            <path d="M5 10v2a7 7 0 0 0 12 5"/>
                            <path d="M15 9.34V5a3 3 0 0 0-5.68-1.33"/>
                            <path d="M9 9v3a3 3 0 0 0 5.12 2.12"/>
                            <line x1="12" x2="12" y1="19" y2="22"/>
                        </svg>
                    </button>
                </div>
            </div>
            <!-- Combined AI Service Panel -->
            <div class="ai-service-container">
                <div class="ai-service-wrapper">
                    <!-- Orb at top with inset wrapper -->
                    <div class="orb-container">
                        <div class="breathing-orb" id="breathingOrb">
                            <div class="orb-outer-wrapper">
                                <div class="orb-middle-wrapper">
                                    <div class="orb-core">
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Service info row -->
                    <div class="service-info-row">
                        <div class="service-name">
                            <svg id="serviceIcon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M12 20h.01"/>
                                <path d="M2 8.82a15 15 0 0 1 20 0"/>
                                <path d="M5 12.859a10 10 0 0 1 14 0"/>
                                <path d="M8.5 16.429a5 5 0 0 1 7 0"/>
                            </svg>
                            <span id="serviceName">OpenAI Realtime</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="right-panel">
            <div id="chatContainer" class="chat-container">
                <div id="chatMessages"></div>
            </div>
        </div>
    </div>
    
    <script>
        let mediaRecorder;
        let ws;
        
        const video = document.getElementById('video');
        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        const muteBtn = document.getElementById('muteBtn');
        const chatMessages = document.getElementById('chatMessages');
        const chatContainer = document.getElementById('chatContainer');
        const breathingOrb = document.getElementById('breathingOrb');
        
        let currentMessage = null;
        let isRecording = false;
        let isMuted = false;
        let audioAnalyzer = null;
        let audioDataArray = null;
        let aiSpeaking = false;
        let aiSpeakingTimeout = null;
        let orbBreathing = false;
        
        // API Style and Provider configuration
        let currentApiStyle = 'OPENAI';  // OPENAI or GEMINI
        let currentProviderBackend = 'OPENAI';  // OPENAI or GEMINI
        
        // Audio context for click sounds
        let clickAudioContext;
        
        // Initialize click audio context
        const initClickAudio = () => {
            if (!clickAudioContext) {
                clickAudioContext = new AudioContext();
            }
        };
        
        // Play click sound
        const playClickSound = () => {
            const audio = new Audio('click.wav');
            audio.volume = 0.3;
            audio.play().catch(e => console.log('Could not play click sound:', e));
        };
        
        // Play start sound
        const playStartSound = () => {
            const audio = new Audio('start.wav');
            audio.volume = 0.3;
            audio.play().catch(e => console.log('Could not play start sound:', e));
        };
        
        // Audio visualizer functions
        const initAudioVisualizer = (stream) => {
            const visualizer = document.getElementById('audioVisualizer');
            const bars = visualizer.querySelectorAll('.audio-bar');
            
            // Create analyzer for the audio stream
            const audioContext = new AudioContext();
            const source = audioContext.createMediaStreamSource(stream);
            audioAnalyzer = audioContext.createAnalyser();
            
            audioAnalyzer.fftSize = 32; // Small size for 8 bars
            audioAnalyzer.smoothingTimeConstant = 0.8;
            
            source.connect(audioAnalyzer);
            audioDataArray = new Uint8Array(audioAnalyzer.frequencyBinCount);
            
            let isActive = false;
            
            const updateVisualizer = () => {
                if (!audioAnalyzer) return;
                
                audioAnalyzer.getByteFrequencyData(audioDataArray);
                
                // Calculate average volume
                const average = audioDataArray.reduce((sum, value) => sum + value, 0) / audioDataArray.length;
                
                // Show/hide visualizer based on audio activity
                if (average > 5) { // Threshold for showing visualizer
                    if (!isActive) {
                        visualizer.classList.add('active');
                        isActive = true;
                    }
                    
                    // Update bars with frequency data
                    for (let i = 0; i < Math.min(bars.length, audioDataArray.length); i++) {
                        const height = Math.max(2, (audioDataArray[i] / 255) * 12);
                        bars[i].style.height = `${height}px`;
                    }
                } else {
                    if (isActive) {
                        visualizer.classList.remove('active');
                        isActive = false;
                        // Reset bars to minimum height
                        bars.forEach(bar => bar.style.height = '2px');
                    }
                }
                
                requestAnimationFrame(updateVisualizer);
            };
            
            updateVisualizer();
        };
        
        const stopAudioVisualizer = () => {
            audioAnalyzer = null;
            audioDataArray = null;
            const visualizer = document.getElementById('audioVisualizer');
            visualizer.classList.remove('active');
            // Reset bars
            const bars = visualizer.querySelectorAll('.audio-bar');
            bars.forEach(bar => bar.style.height = '2px');
        };
        
        
        // Network speed tracking
        let networkSpeed = {
            history: [],
            timestamps: [],
            isTestingSpeed: false
        };
        
        
        // AI Speaking Functions
        function startAISpeaking() {
            if (!aiSpeaking) {
                aiSpeaking = true;
                breathingOrb.classList.remove('breathing');
                breathingOrb.classList.add('speaking');
                
                // Trigger Neural Fire animation when AI speaks
                startNeuralFireAnimation();
                console.log('ðŸŽ™ï¸ AI started speaking - Neural Fire activated');
            }
            
            // Reset the timeout - this extends the animation as long as audio keeps coming
            resetAISpeakingTimeout();
        }
        
        function resetAISpeakingTimeout() {
            // Clear any existing timeout
            if (aiSpeakingTimeout) {
                clearTimeout(aiSpeakingTimeout);
            }
            
            // Calculate when the last scheduled audio will finish playing
            const currentTime = audioContext2?.currentTime || 0;
            const lastAudioEndTime = nextPlayTime || currentTime;
            const timeUntilEnd = Math.max(0, lastAudioEndTime - currentTime);
            
            // Set timeout to stop animation 500ms after the last audio finishes
            const timeoutDuration = (timeUntilEnd * 1000) + 500;
            
            console.log(`â° Animation timeout set for ${Math.max(timeoutDuration, 200)}ms. Sources playing: ${scheduledSources.length}`);
            
            aiSpeakingTimeout = setTimeout(() => {
                // Double-check if there are still scheduled sources playing
                if (scheduledSources.length === 0) {
                    console.log('â° Timeout reached - stopping animation');
                    stopAISpeaking();
                } else {
                    console.log(`â° Timeout reached but ${scheduledSources.length} sources still playing - extending timeout`);
                    // If sources are still playing, check again in 200ms
                    resetAISpeakingTimeout();
                }
            }, Math.max(timeoutDuration, 200));
        }
        
        function stopAISpeaking() {
            if (aiSpeaking) {
                aiSpeaking = false;
                breathingOrb.classList.remove('speaking');
                
                // Reset audio intensity tracking
                lastAudioIntensity = 0;
                if (intensityUpdateTimeout) {
                    clearTimeout(intensityUpdateTimeout);
                    intensityUpdateTimeout = null;
                }
                
                // Stop Neural Fire animation
                stopNeuralFireAnimation();
                
                // Return to breathing state
                startBreathing();
                console.log('ðŸ”‡ AI stopped speaking - returning to thinking state');
            }
            
            if (aiSpeakingTimeout) {
                clearTimeout(aiSpeakingTimeout);
                aiSpeakingTimeout = null;
            }
        }
        
        function startBreathing() {
            if (!orbBreathing && !aiSpeaking) {
                orbBreathing = true;
                breathingOrb.classList.add('breathing');
                console.log('ðŸ’­ AI breathing - thinking state activated');
            }
        }
        
        function stopBreathing() {
            if (orbBreathing) {
                orbBreathing = false;
                breathingOrb.classList.remove('breathing');
                console.log('ðŸ’­ AI breathing stopped');
            }
        }
        
        // Neural Fire Animation Functions
        function startNeuralFireAnimation() {
            // Remove any existing animation classes
            breathingOrb.classList.remove('breathing');
            
            // Add Neural Fire animation
            breathingOrb.classList.add('neural-fire');
        }
        
        function stopNeuralFireAnimation() {
            // Remove Neural Fire animation
            breathingOrb.classList.remove('neural-fire');
            
            // Reset animation speeds to default
            const orbElements = [
                breathingOrb.querySelector('.orb-core'),
                breathingOrb.querySelector('.orb-middle-wrapper'),
                breathingOrb.querySelector('.orb-outer-wrapper')
            ];
            
            orbElements.forEach(element => {
                if (element) {
                    element.style.animationDuration = '';
                }
            });
        }
        
        

        
        function updateAvatarProvider(providerName) {
            // Remove existing provider classes
            breathingOrb.classList.remove('gemini');
            
            // Add new provider class
            if (providerName === 'Gemini' || providerName === 'GEMINI') {
                breathingOrb.classList.add('gemini');
            }
            
            // Update service name with proper names
            const serviceName = document.getElementById('serviceName');
            if (providerName === 'OpenAI' || providerName === 'OPENAI') {
                serviceName.textContent = 'OpenAI Realtime';
            } else if (providerName === 'Gemini' || providerName === 'GEMINI') {
                serviceName.textContent = 'Gemini Live';
            } else {
                serviceName.textContent = `${providerName} Service`;
            }
        }
        
        
        // API Style toggle functionality
        function toggleApiStyle() {
            playClickSound();
            currentApiStyle = currentApiStyle === 'OPENAI' ? 'GEMINI' : 'OPENAI';
            
            const apiStyleText = document.getElementById('apiStyleText');
            const apiStyleIcon = document.getElementById('apiStyleIcon');
            
            if (currentApiStyle === 'GEMINI') {
                apiStyleText.textContent = 'Gemini';
                // Google icon
                apiStyleIcon.innerHTML = '<path d="M12.48 10.92v3.28h7.84c-.24 1.84-.853 3.187-1.787 4.133-1.147 1.147-2.933 2.4-6.053 2.4-4.827 0-8.6-3.893-8.6-8.72s3.773-8.72 8.6-8.72c2.6 0 4.507 1.027 5.907 2.347l2.307-2.307C18.747 1.44 16.133 0 12.48 0 5.867 0 .307 5.387.307 12s5.56 12 12.173 12c3.573 0 6.267-1.173 8.373-3.36 2.16-2.16 2.84-5.213 2.84-7.667 0-.76-.053-1.467-.173-2.053H12.48z"/>';
            } else {
                apiStyleText.textContent = 'OpenAI';
                // OpenAI icon
                apiStyleIcon.innerHTML = '<path d="M22.2819 9.8211a5.9847 5.9847 0 0 0-.5157-4.9108 6.0462 6.0462 0 0 0-6.5098-2.9A6.0651 6.0651 0 0 0 4.9807 4.1818a5.9847 5.9847 0 0 0-3.9977 2.9 6.0462 6.0462 0 0 0 .7427 7.0966 5.98 5.98 0 0 0 .511 4.9107 6.051 6.051 0 0 0 6.5146 2.9001A5.9847 5.9847 0 0 0 13.2599 24a6.0557 6.0557 0 0 0 5.7718-4.2058 5.9894 5.9894 0 0 0 3.9977-2.9001 6.0557 6.0557 0 0 0-.7475-7.0729zm-9.022 12.6081a4.4755 4.4755 0 0 1-2.8764-1.0408l.1419-.0804 4.7783-2.7582a.7948.7948 0 0 0 .3927-.6813v-6.7369l2.02 1.1686a.071.071 0 0 1 .038.052v5.5826a4.504 4.504 0 0 1-4.4945 4.4944zm-9.6607-4.1254a4.4708 4.4708 0 0 1-.5346-3.0137l.142.0852 4.783 2.7582a.7712.7712 0 0 0 .7806 0l5.8428-3.3685v2.3324a.0804.0804 0 0 1-.0332.0615L9.74 19.9502a4.4992 4.4992 0 0 1-6.1408-1.6464zM2.3408 7.8956a4.485 4.485 0 0 1 2.3655-1.9728V11.6a.7664.7664 0 0 0 .3879.6765l5.8144 3.3543-2.0201 1.1685a.0757.0757 0 0 1-.071 0l-4.8303-2.7865A4.504 4.504 0 0 1 2.3408 7.872zm16.5963 3.8558L13.1038 8.364 15.1192 7.2a.0757.0757 0 0 1 .071 0l4.8303 2.7913a4.4944 4.4944 0 0 1-.6765 8.1042v-5.6772a.79.79 0 0 0-.407-.667zm2.0107-3.0231l-.142-.0852-4.7735-2.7818a.7759.7759 0 0 0-.7854 0L9.409 9.2297V6.8974a.0662.0662 0 0 1 .0284-.0615l4.8303-2.7866a4.4992 4.4992 0 0 1 6.6802 4.66zM8.3065 12.863l-2.02-1.1638a.0804.0804 0 0 1-.038-.0567V6.0742a4.4992 4.4992 0 0 1 7.3757-3.4537l-.142.0805L8.704 5.459a.7948.7948 0 0 0-.3927.6813zm1.0976-2.3654l2.602-1.4998 2.6069 1.4998v2.9994l-2.5974 1.4997-2.6067-1.4997Z"/>';
            }
            
            // Reconnect WebSocket with new parameters if connected
            if (ws && ws.readyState === WebSocket.OPEN) {
                console.log(`Switching API Style to ${currentApiStyle}`);
                ws.close();
                connectWebSocket();
            }
        }
        
        // Provider toggle functionality
        function toggleProvider() {
            playClickSound();
            currentProviderBackend = currentProviderBackend === 'OPENAI' ? 'GEMINI' : 'OPENAI';
            
            const providerText = document.getElementById('providerText');
            const providerIcon = document.getElementById('providerIcon');
            const serviceName = document.getElementById('serviceName');
            
            if (currentProviderBackend === 'GEMINI') {
                providerText.textContent = 'Gemini';
                serviceName.textContent = 'Gemini Live';
                // Google icon
                providerIcon.innerHTML = '<path d="M12.48 10.92v3.28h7.84c-.24 1.84-.853 3.187-1.787 4.133-1.147 1.147-2.933 2.4-6.053 2.4-4.827 0-8.6-3.893-8.6-8.72s3.773-8.72 8.6-8.72c2.6 0 4.507 1.027 5.907 2.347l2.307-2.307C18.747 1.44 16.133 0 12.48 0 5.867 0 .307 5.387.307 12s5.56 12 12.173 12c3.573 0 6.267-1.173 8.373-3.36 2.16-2.16 2.84-5.213 2.84-7.667 0-.76-.053-1.467-.173-2.053H12.48z"/>';
            } else {
                providerText.textContent = 'OpenAI';
                serviceName.textContent = 'OpenAI Realtime';
                // OpenAI icon
                providerIcon.innerHTML = '<path d="M22.2819 9.8211a5.9847 5.9847 0 0 0-.5157-4.9108 6.0462 6.0462 0 0 0-6.5098-2.9A6.0651 6.0651 0 0 0 4.9807 4.1818a5.9847 5.9847 0 0 0-3.9977 2.9 6.0462 6.0462 0 0 0 .7427 7.0966 5.98 5.98 0 0 0 .511 4.9107 6.051 6.051 0 0 0 6.5146 2.9001A5.9847 5.9847 0 0 0 13.2599 24a6.0557 6.0557 0 0 0 5.7718-4.2058 5.9894 5.9894 0 0 0 3.9977-2.9001 6.0557 6.0557 0 0 0-.7475-7.0729zm-9.022 12.6081a4.4755 4.4755 0 0 1-2.8764-1.0408l.1419-.0804 4.7783-2.7582a.7948.7948 0 0 0 .3927-.6813v-6.7369l2.02 1.1686a.071.071 0 0 1 .038.052v5.5826a4.504 4.504 0 0 1-4.4945 4.4944zm-9.6607-4.1254a4.4708 4.4708 0 0 1-.5346-3.0137l.142.0852 4.783 2.7582a.7712.7712 0 0 0 .7806 0l5.8428-3.3685v2.3324a.0804.0804 0 0 1-.0332.0615L9.74 19.9502a4.4992 4.4992 0 0 1-6.1408-1.6464zM2.3408 7.8956a4.485 4.485 0 0 1 2.3655-1.9728V11.6a.7664.7664 0 0 0 .3879.6765l5.8144 3.3543-2.0201 1.1685a.0757.0757 0 0 1-.071 0l-4.8303-2.7865A4.504 4.504 0 0 1 2.3408 7.872zm16.5963 3.8558L13.1038 8.364 15.1192 7.2a.0757.0757 0 0 1 .071 0l4.8303 2.7913a4.4944 4.4944 0 0 1-.6765 8.1042v-5.6772a.79.79 0 0 0-.407-.667zm2.0107-3.0231l-.142-.0852-4.7735-2.7818a.7759.7759 0 0 0-.7854 0L9.409 9.2297V6.8974a.0662.0662 0 0 1 .0284-.0615l4.8303-2.7866a4.4992 4.4992 0 0 1 6.6802 4.66zM8.3065 12.863l-2.02-1.1638a.0804.0804 0 0 1-.038-.0567V6.0742a4.4992 4.4992 0 0 1 7.3757-3.4537l-.142.0805L8.704 5.459a.7948.7948 0 0 0-.3927.6813zm1.0976-2.3654l2.602-1.4998 2.6069 1.4998v2.9994l-2.5974 1.4997-2.6067-1.4997Z"/>';
            }
            
            // Reconnect WebSocket with new parameters if connected
            if (ws && ws.readyState === WebSocket.OPEN) {
                console.log(`Switching Provider to ${currentProviderBackend}`);
                ws.close();
                connectWebSocket();
            }
        }
        
        // Dark mode functionality
        function toggleDarkMode() {
            playClickSound();
            document.body.classList.toggle('dark-mode');
            const darkModeBtn = document.getElementById('darkModeToggle');
            
            if (document.body.classList.contains('dark-mode')) {
                darkModeBtn.innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="12" cy="12" r="4"/>
                        <path d="M12 2v2"/>
                        <path d="M12 20v2"/>
                        <path d="m4.93 4.93 1.41 1.41"/>
                        <path d="m17.66 17.66 1.41 1.41"/>
                        <path d="M2 12h2"/>
                        <path d="M20 12h2"/>
                        <path d="m6.34 17.66-1.41 1.41"/>
                        <path d="m19.07 4.93-1.41 1.41"/>
                    </svg>
                `;
                localStorage.setItem('darkMode', 'enabled');
            } else {
                darkModeBtn.innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9"/>
                        <path d="M20 3v4"/>
                        <path d="M22 5h-4"/>
                    </svg>
                `;
                localStorage.setItem('darkMode', 'disabled');
            }
        }
        
        // Check for saved dark mode preference
        if (localStorage.getItem('darkMode') === 'enabled') {
            document.body.classList.add('dark-mode');
            document.getElementById('darkModeToggle').innerHTML = `
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="12" cy="12" r="4"/>
                    <path d="M12 2v2"/>
                    <path d="M12 20v2"/>
                    <path d="m4.93 4.93 1.41 1.41"/>
                    <path d="m17.66 17.66 1.41 1.41"/>
                    <path d="M2 12h2"/>
                    <path d="M20 12h2"/>
                    <path d="m6.34 17.66-1.41 1.41"/>
                    <path d="m19.07 4.93-1.41 1.41"/>
                </svg>
            `;
        }
        
        // Response state tracking
        let isResponseActive = false;
        
        // Universal response management functions
        const handleResponseStart = () => {
            console.log(`ðŸŽ¯ handleResponseStart called - isResponseActive: ${isResponseActive}, currentMessage exists: ${!!currentMessage}`);
            
            // Only start new response if we don't already have one active
            if (!isResponseActive) {
                console.log('ðŸŽ¯ Starting NEW response (detected from first content)');
                
                // Mark response as active
                isResponseActive = true;
                
                // Create new response bubble
                currentMessage = document.createElement('div');
                currentMessage.className = 'chat-message';
                chatMessages.appendChild(currentMessage);
                
                // Start breathing animation when AI starts responding
                if (!aiSpeaking) {
                    startBreathing();
                }
            } else {
                console.log('ðŸ“ Response already active, continuing...');
            }
        };
        
        const handleResponseEnd = (eventData) => {
            console.log('ðŸ Response ended - resetting state');
            
            // Reset response state for next response
            isResponseActive = false;
            
            // Check for interruption based on status
            let isInterrupted = false;
            
            // OpenAI format
            if (eventData.response?.status === 'cancelled') {
                isInterrupted = true;
            }
            
            // Gemini format  
            if (eventData.serverContent?.interrupted) {
                isInterrupted = true;
            }
            
            // Handle interruption
            if (isInterrupted && currentMessage) {
                console.log('âš¡ Response was interrupted');
                
                // Mark as interrupted
                currentMessage.classList.add('interrupted');
                
                // Add interrupted icon
                const interruptIcon = document.createElement('span');
                interruptIcon.innerHTML = ' <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: inline-block; vertical-align: middle;"><path d="M10.513 4.856 13.12 2.17a .5.5 0 0 1 .86.46l-1.377 4.317"/><path d="M15.656 10H20a1 1 0 0 1 .78 1.63l-1.72 1.773"/><path d="M16.273 16.273 10.88 21.83a.5.5 0 0 1-.86-.46l1.92-6.02A1 1 0 0 0 11 14H4a1 1 0 0 1-.78-1.63l4.507-4.643"/><path d="m2 2 20 20"/></svg>';
                interruptIcon.className = 'interrupt-icon';
                interruptIcon.title = 'Response interrupted';
                currentMessage.appendChild(interruptIcon);
                
                // Clear audio buffer
                scheduledSources.forEach(source => {
                    try {
                        source.stop();
                    } catch (e) {
                        // Source might already be stopped
                    }
                });
                scheduledSources = [];
                
                // Reset timing
                nextPlayTime = audioContext2?.currentTime || 0;
            }
            
            // Prepare for next response (reset currentMessage when new content arrives)
            // Note: We don't reset currentMessage here to allow late-arriving content
        };

        // WebSocket event handlers
        const setupWebSocketHandlers = () => {
            ws.onmessage = (event) => {
                if (event.data instanceof ArrayBuffer) {
                    playAudioBuffer(event.data);
                } else {
                    try {
                        const textData = JSON.parse(event.data);
                        
                        // Universal content detection - works for both OpenAI and Gemini protocols
                        const isResponseAudio = (textData.type === 'response.output_audio.delta' && textData.delta) ||
                                               (textData.type === 'response.audio.delta' && textData.delta) ||
                                               (textData.serverContent?.modelTurn?.parts);
                        
                        const isResponseTranscript = (textData.type === 'response.output_audio_transcript.delta' && textData.delta) ||
                                                    (textData.type === 'response.output_audio_transcript.done' && textData.transcript) ||
                                                    (textData.type === 'response.audio_transcript.delta' && textData.delta) ||
                                                    (textData.serverContent?.outputTranscription?.text);
                        
                        const isResponseEnd = (textData.type === 'response.done') ||
                                             (textData.serverContent?.turnComplete) ||
                                             (textData.serverContent?.generationComplete) ||
                                             (textData.serverContent?.interrupted);
                        
                        // Handle audio content (OpenAI and Gemini)
                        if (isResponseAudio) {
                            // Start new response if needed
                            handleResponseStart();
                            
                            if ((textData.type === 'response.output_audio.delta' || textData.type === 'response.audio.delta') && textData.delta) {
                                // OpenAI format
                                try {
                                    const binaryString = atob(textData.delta);
                                    const uint8Array = new Uint8Array(binaryString.length);
                                    for (let i = 0; i < binaryString.length; i++) {
                                        uint8Array[i] = binaryString.charCodeAt(i);
                                    }
                                    const int16Array = new Int16Array(uint8Array.buffer);
                                    playAudioBuffer(int16Array.buffer);
                                } catch (error) {
                                    console.error('Error decoding OpenAI audio:', error);
                                }
                            } else if (textData.serverContent?.modelTurn?.parts) {
                                // Gemini format
                                try {
                                    const parts = textData.serverContent.modelTurn.parts;
                                    for (const part of parts) {
                                        if (part.inlineData?.data) {
                                            const binaryString = atob(part.inlineData.data);
                                            const uint8Array = new Uint8Array(binaryString.length);
                                            for (let i = 0; i < binaryString.length; i++) {
                                                uint8Array[i] = binaryString.charCodeAt(i);
                                            }
                                            const int16Array = new Int16Array(uint8Array.buffer);
                                            playAudioBuffer(int16Array.buffer);
                                        }
                                    }
                                } catch (error) {
                                    console.error('Error decoding Gemini audio:', error);
                                }
                            }
                        }
                        
                        // Handle transcript content (OpenAI and Gemini)  
                        if (isResponseTranscript) {
                            // Start new response if needed
                            handleResponseStart();
                            
                            if ((textData.type === 'response.output_audio_transcript.delta' || textData.type === 'response.audio_transcript.delta') && textData.delta) {
                                // OpenAI format - delta
                                addTextToChat(textData.delta);
                            } else if (textData.type === 'response.output_audio_transcript.done' && textData.transcript) {
                                // OpenAI format - done (full transcript)
                                addTextToChat(textData.transcript);
                            } else if (textData.serverContent?.outputTranscription?.text) {
                                // Gemini format
                                addTextToChat(textData.serverContent.outputTranscription.text);
                            }
                        }
                        
                        // Handle response end (OpenAI and Gemini)
                        if (isResponseEnd) {
                            handleResponseEnd(textData);
                        }
                        
                        // TEMP COMMENTING: User bubble creation calls
                        /*
                        // Handle user transcript (both OpenAI and Gemini formats)
                        if (textData.type === 'conversation.item.input_audio_transcription.delta' && textData.delta) {
                            // OpenAI format
                            addUserMessage(textData.delta);
                        } else if (textData.serverContent?.inputTranscription?.text) {
                            // Gemini format
                            addUserMessage(textData.serverContent.inputTranscription.text);
                        }
                        */
                        
                        if (textData.type === 'switch' && textData.name) {
                            handleProviderSwitch(textData.name);
                        }
                    } catch (error) {
                        console.error('Error parsing text message:', error);
                    }
                }
            };
            
            ws.onerror = (error) => {
                console.error('WebSocket error:', error);
            };
            
            ws.onclose = () => {
                console.log('WebSocket closed');
            };
        };

        // Get PORT from query params if provided (for custom server ports)
        const urlParams = new URLSearchParams(window.location.search);
        const serverPort = urlParams.get('PORT') || '3000';
        
        // Authentication setup (in real app, auth hash would come from backend)
        const API_KEY = 'rs_test_key_123456789';
        const SESSION_ID = 'test-session-001';
        // TODO: In production flow:
        // 1. User logs into your backend with username/password
        // 2. Backend generates HMAC hash using: crypto.createHmac('sha256', accountSecretKey).update(sessionId).digest('hex')
        // WebSocket connection setup function
        const connectWebSocket = async () => {
            return new Promise(async (resolve, reject) => {
                try {
                    console.log('ðŸ” Connecting with session:', SESSION_ID);

                    // Connect with query parameters (new format: rs_key, rs_sessid, rs_api)
                    const wsUrl = `ws://localhost:3000?rs_key=${API_KEY}&rs_sessid=${SESSION_ID}&rs_api=${currentApiStyle}`;
                    console.log('Connecting to WebSocket:', wsUrl);
                    
                    ws = new WebSocket(wsUrl);
                    ws.binaryType = 'arraybuffer'; // Handle binary audio data
                
                ws.onopen = () => {
                    console.log(`WebSocket connected with API Style: ${currentApiStyle}`);
                    setupWebSocketHandlers();
                    
                    // Send appropriate session configuration based on API style
                    if (currentApiStyle === 'OPENAI') {
                        // OpenAI session.update message
                        const sessionUpdateMessage = {
                            type: "session.update",
                            session: {
                                modalities: ["text", "audio"],
                                turn_detection: { type: "server_vad", "silence_duration_ms": 700 },
                                voice: "ash",
                                input_audio_transcription: { model: "whisper-1", language: 'en' },
                                input_audio_format: "pcm16",
                                output_audio_format: "pcm16",
                                instructions: "Talk to user"
                            }
                        };
                        console.log('Sending OpenAI session.update:', sessionUpdateMessage);
                        ws.send(JSON.stringify(sessionUpdateMessage));
                    } else {
                        // Gemini setup message
                        const setupMessage = {
                            setup: {
                                model: "models/gemini-2.0-flash-live-001",  // Critical: Must use this model for proper generationComplete events
                                generationConfig: {
                                    responseModalities: ["AUDIO"]
                                },
                                outputAudioTranscription: {},
                                inputAudioTranscription: {},
                                systemInstruction: {
                                    parts: [{ text: "Talk to user" }]
                                }
                            }
                        };
                        console.log('Sending Gemini setup:', setupMessage);
                        ws.send(JSON.stringify(setupMessage));
                    }
                    
                    resolve();
                };
                
                ws.onerror = (error) => {
                    console.error('WebSocket connection error:', error);
                    reject(error);
                };
                } catch (error) {
                    console.error('Error setting up WebSocket:', error);
                    reject(error);
                }
            });
        };
        
        // Initial WebSocket connection
        connectWebSocket().catch(err => {
            console.error('Failed to connect to WebSocket:', err);
        });
        
        
        let audioContext2;
        let audioQueue = [];
        let isPlaying = false;
        let nextPlayTime = 0;
        let scheduledSources = []; // Track scheduled audio sources
        
        // Initialize audio playback context
        const initAudioPlayback = () => {
            if (!audioContext2) {
                audioContext2 = new AudioContext({ sampleRate: 24000 });
                nextPlayTime = audioContext2.currentTime;
            }
        };
        
        // Audio intensity analysis
        const getAudioIntensity = (int16Array) => {
            if (int16Array.length === 0) return 0;
            
            // Calculate RMS (Root Mean Square) for audio intensity
            let sum = 0;
            for (let i = 0; i < int16Array.length; i++) {
                sum += int16Array[i] * int16Array[i];
            }
            const rms = Math.sqrt(sum / int16Array.length);
            
            // Normalize to 0-1 range and apply some smoothing
            return Math.min(rms / 8192, 1.0); // Adjust 8192 for sensitivity
        };
        
        let lastAudioIntensity = 0;
        let intensityUpdateTimeout = null;
        
        // Update orb animation based on audio intensity
        const updateOrbIntensity = (intensity) => {
            // Smooth the intensity changes
            const smoothedIntensity = (lastAudioIntensity * 0.7) + (intensity * 0.3);
            lastAudioIntensity = smoothedIntensity;
            
            // Clear any existing timeout
            if (intensityUpdateTimeout) {
                clearTimeout(intensityUpdateTimeout);
            }
            
            // Apply intensity to Neural Fire animation speed
            if (aiSpeaking && breathingOrb.classList.contains('neural-fire')) {
                let animationSpeed;
                
                if (smoothedIntensity > 0.6) {
                    animationSpeed = '1.5s'; // Fast for high intensity
                } else if (smoothedIntensity > 0.3) {
                    animationSpeed = '2s';   // Medium for mid intensity  
                } else if (smoothedIntensity > 0.1) {
                    animationSpeed = '2.5s'; // Normal for low intensity
                } else {
                    animationSpeed = '3s';   // Slow for very low intensity
                }
                
                // Apply the speed to all neural fire elements
                const orbElements = [
                    breathingOrb.querySelector('.orb-core'),
                    breathingOrb.querySelector('.orb-middle-wrapper'),
                    breathingOrb.querySelector('.orb-outer-wrapper')
                ];
                
                orbElements.forEach(element => {
                    if (element) {
                        element.style.animationDuration = animationSpeed;
                    }
                });
                
                console.log(`ðŸŽµ Audio intensity: ${(smoothedIntensity * 100).toFixed(1)}% - Speed: ${animationSpeed}`);
            }
            
            // Reset animation speed after a delay if no new audio
            intensityUpdateTimeout = setTimeout(() => {
                if (aiSpeaking && breathingOrb.classList.contains('neural-fire')) {
                    const orbElements = [
                        breathingOrb.querySelector('.orb-core'),
                        breathingOrb.querySelector('.orb-middle-wrapper'),
                        breathingOrb.querySelector('.orb-outer-wrapper')
                    ];
                    
                    orbElements.forEach(element => {
                        if (element) {
                            element.style.animationDuration = '2.5s'; // Reset to default
                        }
                    });
                }
            }, 200);
        };

        // Play audio buffer
        const playAudioBuffer = async (pcm16Data) => {
            try {
                if (!audioContext2) {
                    initAudioPlayback();
                    await audioContext2.resume(); // Ensure context is resumed
                }
                
                const int16Array = new Int16Array(pcm16Data);
                const float32Array = new Float32Array(int16Array.length);
                
                for (let i = 0; i < int16Array.length; i++) {
                    float32Array[i] = int16Array[i] / 32768.0;
                }
                
                if (int16Array.length === 0) return;
                
                // Analyze audio intensity for real-time sync
                const audioIntensity = getAudioIntensity(int16Array);
                updateOrbIntensity(audioIntensity);
                
                // Activate AI avatar when audio starts playing
                startAISpeaking();
                
                // Keep extending the timeout as long as audio keeps coming
                resetAISpeakingTimeout();
                
                // Create audio buffer
                const audioBuffer = audioContext2.createBuffer(1, float32Array.length, 24000);
                audioBuffer.copyToChannel(float32Array, 0);
                
                // Create and schedule audio source
                const source = audioContext2.createBufferSource();
                source.buffer = audioBuffer;
                source.connect(audioContext2.destination);
                
                const currentTime = audioContext2.currentTime;
                const playTime = Math.max(currentTime, nextPlayTime);
                
                source.start(playTime);
                nextPlayTime = playTime + audioBuffer.duration;
                
                // Track scheduled source
                scheduledSources.push(source);
                
                // Remove from tracking when it ends
                source.onended = () => {
                    const index = scheduledSources.indexOf(source);
                    if (index > -1) scheduledSources.splice(index, 1);
                    
                    console.log(`ðŸŽµ Audio source ended. Remaining sources: ${scheduledSources.length}`);
                    
                    // If no more audio sources are playing, stop avatar animation after a short delay
                    if (scheduledSources.length === 0) {
                        setTimeout(() => {
                            if (scheduledSources.length === 0) {
                                console.log('ðŸ”‡ All audio sources finished - stopping animation');
                                stopAISpeaking();
                            }
                        }, 300); // Small delay to avoid flickering
                    }
                };
                
            } catch (error) {
                console.error('Error playing audio:', error);
            }
        };

        const addTextToChat = (text) => {
            // handleResponseStart() should have created currentMessage already
            // If it doesn't exist, something went wrong - create it as fallback
            if (!currentMessage) {
                console.warn('âš ï¸ addTextToChat called without active message - creating fallback bubble');
                currentMessage = document.createElement('div');
                currentMessage.className = 'chat-message';
                chatMessages.appendChild(currentMessage);
            }
            
            currentMessage.textContent += text;
            chatContainer.scrollTop = chatContainer.scrollHeight;
        };

        // TEMP COMMENTING: User bubble creation
        /*
        const addUserMessage = (text) => {
            const userMessage = document.createElement('div');
            userMessage.className = 'chat-message user';
            userMessage.textContent = text;
            chatMessages.appendChild(userMessage);
            chatContainer.scrollTop = chatContainer.scrollHeight;
        };
        */

        // Network speed monitoring
        const measureNetworkSpeed = async () => {
            if (networkSpeed.isTestingSpeed) return; // Prevent overlapping tests
            
            networkSpeed.isTestingSpeed = true;
            document.getElementById('networkStatusText').textContent = 'Testing...';
            
            try {
                const testSizeKB = 500; // 500KB test file
                const start = performance.now();
                
                // Use a cache-busting parameter to ensure fresh download
                const cacheBuster = Date.now() + Math.random();
                const response = await fetch(`https://httpbin.org/bytes/${testSizeKB * 1024}?cb=${cacheBuster}`, {
                    cache: 'no-cache',
                    headers: {
                        'Cache-Control': 'no-cache',
                        'Pragma': 'no-cache'
                    }
                });
                
                await response.blob();
                const duration = performance.now() - start;
                const speedMbps = ((testSizeKB * 8) / (duration / 1000)) / 1000; // Convert to Mbps
                
                // Update UI
                updateNetworkSpeedDisplay(speedMbps);
                
                // Store in history (keep last 20 measurements)
                networkSpeed.history.unshift(speedMbps);
                networkSpeed.timestamps.unshift(new Date());
                if (networkSpeed.history.length > 20) {
                    networkSpeed.history.pop();
                    networkSpeed.timestamps.pop();
                }
                
                updateSpeedChart();
                
            } catch (error) {
                console.error('Network speed test failed:', error);
                document.getElementById('networkStatusText').textContent = 'Test Failed';
                document.getElementById('networkSpeed').textContent = 'Error';
            }
            
            networkSpeed.isTestingSpeed = false;
        };
        
        const updateNetworkSpeedDisplay = (speedMbps) => {
            const roundedSpeed = Math.round(speedMbps * 10) / 10; // Round to 1 decimal
            document.getElementById('networkSpeed').textContent = roundedSpeed;
            
            // Update status based on speed
            const statusElement = document.getElementById('networkStatus');
            const statusTextElement = document.getElementById('networkStatusText');
            
            if (speedMbps > 10) {
                statusElement.style.background = '#28a745'; // Green
                statusTextElement.textContent = 'Excellent';
            } else if (speedMbps > 5) {
                statusElement.style.background = '#28a745'; // Green  
                statusTextElement.textContent = 'Good';
            } else if (speedMbps > 2) {
                statusElement.style.background = '#ffc107'; // Yellow
                statusTextElement.textContent = 'Fair';
            } else if (speedMbps > 0.5) {
                statusElement.style.background = '#fd7e14'; // Orange
                statusTextElement.textContent = 'Poor';
            } else {
                statusElement.style.background = '#dc3545'; // Red
                statusTextElement.textContent = 'Very Poor';
            }
        };
        
        const updateSpeedChart = () => {
            const speedBars = document.getElementById('speedBars');
            const timeAxis = document.getElementById('timeAxis');
            speedBars.innerHTML = '';
            timeAxis.innerHTML = '';
            
            if (networkSpeed.history.length === 0) return;
            
            const maxSpeed = Math.max(...networkSpeed.history, 1);
            
            // Create speed bars
            networkSpeed.history.forEach((speed, index) => {
                const bar = document.createElement('div');
                const heightPercent = (speed / maxSpeed) * 100;
                
                // Color based on speed quality
                let color = '#dc3545'; // Red (poor)
                if (speed > 10) color = '#28a745'; // Green (excellent)
                else if (speed > 5) color = '#28a745'; // Green (good)
                else if (speed > 2) color = '#ffc107'; // Yellow (fair)
                else if (speed > 0.5) color = '#fd7e14'; // Orange (poor)
                
                bar.style.cssText = `
                    width: 5px;
                    height: ${heightPercent}%;
                    background: ${color};
                    margin-right: 1px;
                    transition: height 0.3s ease;
                    flex-shrink: 0;
                `;
                
                speedBars.appendChild(bar);
            });
            
            // Create time axis labels
            const now = new Date();
            const timeLabels = [];
            
            // Show times for first, middle, and last measurements
            const timestamps = networkSpeed.timestamps;
            const showIndices = [];
            
            if (timestamps.length > 0) {
                showIndices.push(0); // First
                if (timestamps.length > 2) {
                    showIndices.push(Math.floor(timestamps.length / 2)); // Middle
                }
                if (timestamps.length > 1) {
                    showIndices.push(timestamps.length - 1); // Last
                }
            }
            
            // Create time labels with fixed positioning
            networkSpeed.history.forEach((_, i) => {
                const label = document.createElement('div');
                label.style.cssText = `
                    width: 5px;
                    margin-right: 1px;
                    text-align: center;
                    opacity: ${showIndices.includes(i) ? '1' : '0'};
                    flex-shrink: 0;
                    font-size: 8px;
                `;
                
                if (showIndices.includes(i) && timestamps[i]) {
                    const secondsAgo = Math.floor((now - timestamps[i]) / 1000);
                    if (secondsAgo < 60) {
                        label.textContent = secondsAgo === 0 ? 'now' : `${secondsAgo}s`;
                    } else {
                        const minutesAgo = Math.floor(secondsAgo / 60);
                        label.textContent = `${minutesAgo}m`;
                    }
                }
                
                timeAxis.appendChild(label);
            });
        };
        
        const startNetworkSpeedMonitoring = () => {
            // Initial test
            measureNetworkSpeed();
            
            // Test every 10 seconds
            setInterval(measureNetworkSpeed, 10000);
        };
        

        
        // Get user media (but don't start video preview immediately)
        let userMediaStream = null;
        
        const initializeUserMedia = async () => {
            if (!userMediaStream) {
                userMediaStream = await navigator.mediaDevices.getUserMedia({ 
                    video: true, 
                    audio: { sampleRate: 24000 } // OpenAI expects 24kHz
                });
            }
            return userMediaStream;
        };
        
        let audioContext;
        let audioWorkletNode;
        
        // Start recording function
        const startRecording = async () => {
            try {
                // Clear chat history
                chatMessages.innerHTML = '';
                currentMessage = null;
                
                // Update service name based on current provider backend
                const serviceName = document.getElementById('serviceName');
                serviceName.textContent = currentProviderBackend === 'OPENAI' ? 'OpenAI Realtime' : 'Gemini Live';
                
                // Update AI avatar to current provider backend
                updateAvatarProvider(currentProviderBackend === 'OPENAI' ? 'OpenAI' : 'Gemini');
                stopAISpeaking();
                stopBreathing();
                
                // Start breathing animation after a short delay
                setTimeout(() => {
                    startBreathing();
                }, 1000);
                
                
                // Ensure WebSocket is connected
                if (!ws || ws.readyState === WebSocket.CLOSED || ws.readyState === WebSocket.CLOSING) {
                    console.log('Reconnecting WebSocket...');
                    await connectWebSocket();
                }
                
                // Get user media and start video preview
                const stream = await initializeUserMedia();
                video.srcObject = stream;
                
                // Initialize audio visualizer
                initAudioVisualizer(stream);
                
                // Play start sound when video is ready to play
                video.addEventListener('canplay', () => {
                    playStartSound();
                }, { once: true });
                
                video.play();
                
                // Initialize both recording and playback audio contexts
                audioContext = new AudioContext({ sampleRate: 24000 });
                initAudioPlayback();
                await audioContext2.resume();
                
                // Load AudioWorklet processor
                await audioContext.audioWorklet.addModule('audio-processor.js');
                
                const source = audioContext.createMediaStreamSource(stream);
                
                // Create AudioWorkletNode for modern audio processing
                audioWorkletNode = new AudioWorkletNode(audioContext, 'audio-processor');
                
                // Handle messages from AudioWorklet
                audioWorkletNode.port.onmessage = (event) => {
                    if (event.data.type === 'audio-data' && ws.readyState === WebSocket.OPEN && !isMuted) {
                        // Convert ArrayBuffer to base64
                        const pcm16Array = new Int16Array(event.data.data);
                        const uint8Array = new Uint8Array(pcm16Array.buffer);
                        const base64Audio = btoa(String.fromCharCode(...uint8Array));
                        
                        // Create appropriate format event based on API style
                        let audioEvent;
                        if (currentApiStyle === 'OPENAI') {
                            // OpenAI format
                            audioEvent = {
                                type: "input_audio_buffer.append",
                                audio: base64Audio
                            };
                        } else {
                            // Gemini format
                            audioEvent = {
                                realtimeInput: {
                                    audio: {
                                        mimeType: "audio/pcm;rate=24000",
                                        data: base64Audio
                                    }
                                }
                            };
                        }
                        
                        ws.send(JSON.stringify(audioEvent));
                    }
                };
                
                // Connect the audio processing pipeline
                source.connect(audioWorkletNode);
                
                startBtn.disabled = true;
                stopBtn.disabled = false;
                currentMessage = null;
                
            } catch (error) {
                console.error('Error starting audio:', error);
            }
        };
        
        // Stop recording function
        const stopRecording = () => {
            playClickSound();
            
            // Stop all scheduled audio sources immediately
            scheduledSources.forEach(source => {
                try {
                    source.stop();
                } catch (e) {
                    // Source might already be stopped
                }
            });
            scheduledSources = [];
            
            // Stop all AI visualizations
            stopAISpeaking();
            stopBreathing();
            
            // Clear audio buffers and reset timing
            audioQueue = [];
            isPlaying = false;
            if (audioContext2) {
                nextPlayTime = audioContext2.currentTime;
            }
            
            // Mark any current message as interrupted
            if (currentMessage) {
                currentMessage.classList.add('interrupted');
                const interruptIcon = document.createElement('span');
                interruptIcon.innerHTML = ' <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: inline-block; vertical-align: middle;"><path d="M10.513 4.856 13.12 2.17a.5.5 0 0 1 .86.46l-1.377 4.317"/><path d="M15.656 10H20a1 1 0 0 1 .78 1.63l-1.72 1.773"/><path d="M16.273 16.273 10.88 21.83a.5.5 0 0 1-.86-.46l1.92-6.02A1 1 0 0 0 11 14H4a1 1 0 0 1-.78-1.63l4.507-4.643"/><path d="m2 2 20 20"/></svg>';
                interruptIcon.className = 'interrupt-icon';
                interruptIcon.title = 'Stopped by user';
                currentMessage.appendChild(interruptIcon);
                currentMessage = null;
            }
            
            // Close recording audio context
            if (audioWorkletNode) {
                audioWorkletNode.disconnect();
                audioWorkletNode = null;
            }
            if (audioContext) {
                audioContext.close();
                audioContext = null;
            }
            
            // Stop audio visualizer
            stopAudioVisualizer();
            
            // Stop video preview
            if (userMediaStream) {
                userMediaStream.getTracks().forEach(track => track.stop());
                userMediaStream = null;
                video.srcObject = null;
            }
            
            // Close WebSocket connection to trigger server cleanup
            if (ws && ws.readyState === WebSocket.OPEN) {
                console.log('Closing WebSocket connection...');
                ws.close();
            }
            
            startBtn.disabled = false;
            stopBtn.disabled = true;
        };
        
        // Mute toggle function
        const toggleMute = () => {
            playClickSound();
            isMuted = !isMuted;
            if (isMuted) {
                muteBtn.classList.add('pressed');
            } else {
                muteBtn.classList.remove('pressed');
            }
        };
        
        
        // Assign event handlers
        startBtn.onclick = startRecording;
        stopBtn.onclick = stopRecording;
        muteBtn.onclick = toggleMute;
    </script>
</body>
</html>